# 스레드 풀 활용

</br>

## 8.1 작업과 실행 정책 간의 보이지 않는 연결 관계
- Executor 프레임웍이 나름대로 실행정책을 정하거나 변경하는데 있어 유연성을 가지고 있지만, 특정 형태의 실행정책에서는 실행할 수 없는 작업이 존재함
- 일정한 조건을 갖춘 실행 정책이 필요한 작업에는 아래와 같은 것들이 있음
	- **의존성이 있는 작업**
		- 다른 작업에 의존성을 갖는 작업을 스레드 풀에 올려 실행하려는 경우에는 실행 정책에 보이지 않는 조건을 거는 셈
		- 스레드 풀이 동작하는 동안 활동성 문제(liveness problem)가 발생하지 않도록 하려면 실행 정책에 대한 이와 같은 보이지 않는 조건을 면밀하게 조사하고 관리해야 함
	- **스레드 한정 기법을 사용하는 작업**
		- 단일 스레드로 동작하는 스레드 풀은 여러 스레드가 동작하는 경우보다 병렬 프로그램 입장에서 안전하게 동작함
		- 작업에서 사용하는 객체를 스레드 수준에 맞춰 한정할 수 있으므로, 같은 스레드에 한정되어 있는 객체라면 해당 객체가 스레드 안전성을 갖추고 있지 않다해도 얼마든지 마음대로 사용할 수 있음
		- 해당 작업을 실행하려면 Executor 프레임웍이 단일 스레드로 동작해야 한다는 조건이 생기기 때문에 작업과 실행정책 간의 보이지 않는 연결고리가 걸려있는 상황
		- 단일 스레드를 사용하는 풀 대신 여러 개의 스레드를 사용하는 풀로 변경하면, 스레드 안전성을 쉽게 잃을 수 있음
	- **응답 시간이 민감한 작업**
		- 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어짐
	- **ThreadLocal을 사용하는 작업**
		- ThreadLocal을 사용하면 각 스레드에서 같은 이름의 값을 각자의 버전으로 유지할 수 있음
		- Executor는 상황이 되는대로 기존 스레드를 최대한 재사용함
		- 기본적으로 포함된 Executor는 처리해야할 작업의 수가 적을 땐 쉬는 스레드를 제거하기도 하고, 작업량이 많을 땐 새로운 스레드를 생성하여 사용하기도 함
		- 스레드 풀에 속한 스레드에서 ThreadLocal을 사용할 떄에는 현재 실행 중인 작업이 끝나면 더 이상 사용하지 않을 값만 보관해야함
		- ThreadLocal을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안됨
- 스레드 풀은 동일하고 서로 독립적인 다수의 작업을 실행할 떄 가장 효과적임
- 실행시간이 오래 걸리는 작업과 금방 끝나는 작업을 섞여서 실행하도록 하면 풀의 크기가 굉장히 크지 않는 한 작업 실행을 방해하는 것과 비슷한 상황이 발생함
- 크기가 제한되어 있는 스레드 풀에 다른 작업에 의존성을 갖고 있는 작업을 등록하면 데드락이 발생할 가능성이 높음
- 다른 작업에 의존성이 있는 작업을 실행해야할 때는 스레드 풀의 크기를 충분히 크게 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야함
- 스레드 한정 기법을 사용하는 작업은 반드시 순차적으로 실행돼야 함

</br>

### 8.1.1 스레드 부족 데드락
- 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높음
- 단일 스레드로 동작하는 Executor에서 다른 작업을 큐에 등록하고 해당 작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸림
- 스레드 풀의 크기가 크더라도 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 바등려고 대기 중이라면 이와 동일한 상황이 발생할 수 있음
	- 스레드 부족 데드락(thread starvation deadlock)이라 함
- 스레드 부족 데드락은 특정 자원을 확보하고자 계속해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는 것처럼 끝없이 계속 대기할 가능성이 있는 기능을 사용하는 작업이 풀에 등록된 경우에는 언제든지 발생할 수 있음
~~~java
public class ThreadDeadlock {
    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class RenderPageTask implements Callable<String> {
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            // 데드락 발생
            return header.get() + page + footer.get();
        }
    }
}
~~~
- Executor에서 스레드를 하나만 쓰도록 구현하다면 ThreadDeadlock 클래스는 항상 데드락에 걸림
- 배리어(barrier)를 사용해 서로의 동작을 조율하는 작업 역시 풀의 크리가 충분히 크지 않다면 스레드 부족 데드락이 발생할 수 있음
- 완전히 독립적이지 않은 작업을 Executor에 등록할 때는 항상 스레드 부족 데드락이 발생할 수 있다느 사실을 염두에 둬야 하며, 작업을 구현한 코드나 Executor를 설정하는 설정 파일 등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 함
- 스레드 풀의 크기는 직접적으로 지정하는 것 이외에도 스레드 풀에서 필요로 하는 자원이 제한되어 원하는 크기보다 작은 수준에서 동작하는 경우도 있음

### 8.1.2 오래 실행되는 작업
- 오래 실행되는 작업이 있다면 스레드 풀은 전체적인 작업 실행 과정에 어려움을 겪게 되며 금방 끝나는 작업이 실행되는 속도에도 영향을 미침
- 제한 없이 대기하느 ㄴ기능 대신 일저 ㅇ시간 동안만 대기하는 메소드를 사용할 수 있다면, 오래 실행되는 작업이 주는 악영향을 줄일 수 있는 하나의 방법으로 볼 수 있음
- 자바 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않는 것과 시간이 제한된 것이 함께 만들어져 있음
	- Thread.join(), BlockingQueue.put(), CountDownLatch.await(), Selector.select(), etc..
- 스레드 풀을 사용하는 도중에 모든 스레드에서 실행 중인 작업이 대기 상태에 빠지는 경우가 자주 발생한다면, 스레드 풀의 크기가 작다는 것으로 이해할 수도 있음

</br>

## 8.2 스레드 풀 크기 조절
- 스레드 풀의 가장 이상적인 크기는 스레드 풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정됨
- 스레드 풀의 크기는 설정 파일이나 Runtime.availableProcess 등의 메소드 결과 값에 따라 동적으로 지정되어야 함
- 스레드 풀의 크기가 너무 크게 설정되어 있다면, 스레드는 CPU나 메모리 등의 자원을 더 확보하기 위해 경쟁하게 됨 --> 자원 부족으로 이어짐
- 스레드 풀의 크기가 너무 작다면, 작업량은 계속해서 쌓이는데 CPU나 메모리는 남아돌며 작업 처리속도가 떨어질 수 있음
- 스레드 풀의 크기를 적절하게 산정하려면 현재 컴퓨터 환경이 어느정도인지 확인해야 하고, 확보하고 있는 자원의 양도 알아야 하며, 해야할 작업이 어떻게 동작하는지도 정확히 알아야 함
- CPU를 많이 사용하는 작업의 경우 N개의 CPU를 탑재하고 있는 하드웨어에서 스레드 풀을 사용할 때는 스레드의 개수를 N+1개로 맞추면 최적의 성능을 발휘한다고 알려져 있음
- I/O 작업이 많거나 다른 브로킹 작업을 해야하는 경우라면 어느 순간에는 모든 스레드가 대기 상태에 들어가 전체 진행이 멈출수 있기 때문에 스레드 풀의 크기를 훨씬 크게 잡아야할 필요가 있음
- 스레드 풀의 크기를 정하려면 처리해야 할 작업이 시작해서 끝날 때까지 실제 작업하는 시간 대비 시간의 비율을 구해봐야함

~~~
Ncpu = CPU 개수
Ucpu = 목표로 하는 CPU 활용도. 0보다 크거나 같고 1보다 작거나 같음
W/C = 작업 시간 대비 대기 시간의 비율

CPU가 원하는 활용도를 유지할 수 있는 스레드 풀의 크기는  
Nthreads = Ncpu * Ucput * ( 1 + W/C )
~~~

- CPU의 개수는 Runtime 클래스의 availableProcessors 메소드로 아래와 같이 확인 가능    
`int N_CPU = Runtime.getRuntime().availableProcessors();`  

- CPU가 아닌 다른 자원을 대상으로 하는 스레드 풀의 크기를 정하는 일은 CPU 보다 쉬움
	- 메모리, 파일 핸들, 소켓 핸들, 데이터베이스 연결, etc...
	- 각 작업에서 실제로 필요한 자원의 양을 모두 더한 값을 자원의 전체 개수로 나워주면 됨 --> 스레드 풀의 최대 크기에 해당됨
- 각 작업 하나가 데이터베이스 연결 하나르 ㄹ사용한다고 가정하면 스레드 풀의 실제 크기는 데이터베이스 연결 풀의 크기로 제한되는 셈
- 데이터베이스 연결 풀을 특정 스레드 풀에서만 사용한다고 하면, 데이터베이스 연결 풀에 확보된 연결 가운데 실제로 스레드 풀의 크기에 해당되는 연결만 사용될 것 

</br>

## 8.3 ThreadPoolExecutor 설정
- 
