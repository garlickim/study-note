# 성능, 확장성
- 스레드를 사용하는 가장 큰 목적은 성능을 높이고자 하는 것
- 스레드를 사용하면 시스템 자원을 효율적으로 활용할 수 있고, 애플리케이션으로 하여금 시스템이 갖고 있는 능력을 최대한 사용하게 할 수 있음
- 성능을 높이는 방법은 대부분 애플리케이션 구조를 복잡하게 만들어야 하는 경우가 많고, 이에 따라 안전성과 활동성에 문제가 생길 가능성도 적지 않음
- 성능 때문에 안전성을 해쳐서는 안됨

</br>

## 11.1 성능에 대해
- 성능을 높인다는 말은 더 적은 자원을 사용하면서 더 많은 일을 하도록 한다는 것
	- 자원 : CPU, 메모리, 네트웍 속도, DB 처리 속도, etc..
- 어떤 작업을 실행할 때 충분하지 못한 특정 자원 때문에 성능이 떨어지는 현상이 나타난다면, 작업의 성능이 해당 자원에 좌우된다고 함
- 여러 개의 스레드를 사용하려 한다면 당일 스레드 사용보다는 성능상의 비용을 지불해야만 함
	- 스레드 간의 작업을 조율하는데 필요한 오버헤드(락 걸기, 신호 보내기, 메모리 동기화 등)
	- 잦은 컨텍스트 스위칭
	- 빈번한 스레드 생성 및 제거
	- 여러 스레드를 효율적으로 스케쥴링 해야하는 것
- 잘못 설계된 병렬 애플리케이션은 순차적으로 작업을 처리하는 프로그램보다 느리게 동작하는 경우도 있음
- 성능을 목표로한 병렬 프로그래밍을 위해서는 두가지 부분을 우선적으로 생각해야 함
	- 프로그램이 확보할 수 있는 모든 자원을 최대한 활용해야 함
	- 남는 자원이 생길 때마다 그 자원을 최대한으로 활용할 수 있도록 해야 함
- 프로그램에서 스레드를 활용하면 작업을 잘게 나눠 시스템에 꽂힌 CPU가 충분히 동작해야할 만큼의 작업을 실행시켜 노는 CPU가 없을 만큼 작업 실행 성능을 높일 수 있음

</br>

### 11.1.1 성능 대 확장성
- 어플이케이션의 성능은 여러 자료로 측정 가능하며, 서비스 시간, 대기 시간, 처리량 등의 수치를 뽑아 얼마나 빠른지 그리고 얼마나 많은 양을 할 수 있는지를 알 수 있음
- 확장성(scalability)은 CPU, 메모리, 디스크, I/O 처리 장치 등의 추가적인 장비를 사용해 처리량이나 용량을 얼마나 쉽게 키울 수 있는지를 말함
- 단일 스레드 환경의 애플리케이션은 별 다른 튜닝을 하지 않아도 3-티어 모델의 애플리케이션 보다 성능이 좋은 경우가 많음
- 그러나, 최대 부하를 넘어서는 경우 단시간에 처리 용량을 증가시킬 수 없으므로 서비스 시간이 훨씬 길어져 하드웨어 자원의 양이 크게 늘어나는 일을 감수해야 함

### 11.1.2 성능 트레이드 오프 측정
- 트레이드 오프에서 어떤 부분을 선택해야 할지를 결정하는데 필요한 정보가 충분하지 않은 경우가 많음
- 최적화 기법을 너무 이른 시점에 적용하지 말아야 함
- 제대로 동작하게 만들고 난 다음에 빠르게 동작하도록 최적화해야 하며, 예상한 것보다 심각하게 성능이 떨어지는 경우에만 최적화 기법을 적용하는 것으로도 충분함
- 성능을 최적화하는 다수의 경우에 코드의 가독성과 유지보수의 용이함을 비용으로 지불함
	- 좀 더 '최적화'되거나 동작하는 모습이 덜 분명한 코드일수록 이해하기가 어렵고 유지보수도 어려움
- 병렬 프로그램에서 발생하는 버그는 추적하고 발견해 수정하기가 어렵지만, 버그의 원이이 될 가능성이 조금이라도 있는 위험도 높은 코드의 경우 매우 주의 깊게 살펴봐야 함
- 성능을 높이기 위해 안전성을 떨어뜨리는 것은 최악의 상황이며, 안전성과 성능 둘 다를 놓칠 수 있음
- 성능을 튜닝하는 모든 과정에서 항상 성능 목표에 대한 명확한 요구 사항이 있어야 하며, 그에 따라 어느 부분을 튜닝하고 어느 시점에서 튜닝을 그만 둬야하는지를 판단할 수 있음
- 특별히 성능을 높이길 원하지 않는다면, 안정성과 유지보수에 대한 비용을 지불해 가면서 성능을 높일 필요는 없음
- 추측하지 말고, 실제로 측정해보라

</br>

## 11.2 암달의 법칙
- 암달의 법칙(Amdahl’s law)을 사용하면 병렬 작업과 순차 작업의 비율에 따라 하드웨어 자원을 추가로 투입했을 때 이론적으로 속도가 얼마나 빨라질지에 대한 예측 값을 얻을 수 있음
- `속도 증가량 <= 1 / ( F + (1-F) / N )`  
	- F : 순차적으로 실행돼야 하는 작업의 비율
	- N : 하드웨어에 꽂혀 있는 프로세서의 개수
- 프로세서인 N 이 무한대면 속도 증가량은 최대 1/F
- 순차적 실행 부분이 전체 50% 라면 프로세서를 아무리 많이 꽂아도 겨우 2배 빨라지는 것
- 암달의 법칙을 이용하면 순차 처리 하는 부분이 많아질때 얼마나 느려지는지 수치화 할 수 있음
- 하드웨어에 CPU 가 10개 꽂혀있으면 10%의 순차작업을 갖고 있는 프로그램은 최고 5.3배 만큼의 속도가 증가 할 수 있음
	- 53%의 CPU 활용도를 가짐 (cpu가 10개이므로 5.3 * 	10 ==> 53)
	- 1 / ( 0.1 + ( 1 – 0.1) / 10) = 5.26...
- 순차적으로 실행해야하는 부분이 조금이라도 늘면 프로세스의 비해 얻을 수 있는 속도 증가량이 크게 떨어짐
![amdahl-ex01](/img/amdahl-ex01.png)      


~~~java
public class WorkerThread extends Thread {
    private final BlockingQueue<Runnable> queue;
    
    public WorkerThread(BlockingQueue<Runnable> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Runnable task = queue.take();
                task.run();
            } catch (InterruptedException e) {
                break; /* 스레드를 종료시킨다. */
            }
        }
    }
}
~~~
- 작업 큐에서 작업을 하나씩 뽑는 부분이 순차 처리해야 하는 부분
- 모든 작업 스레드가 작업 큐를 쓸 수 있기 때문에, 적당한 동기화 작업이 선행 되어야 함
- LinkedList 보다는 LinkedBlockingQueue 를 사용하면 대기하는 시간이 훨씬 적게 들지만,어찌됐던 간에 순차적으로 처리해야 하는건 마찬가지
- Runnable 인터페이스는 항상 실행 결과를 로그 파일에 적어두거나, 특정 데이터 구조에 실행 결과를 쌓아두도록 되어 있음
	- 로그 파일이나 결과를 저장하는 기타 데이터 구조 모두 무작위 순서로 만들어내는 결과를 받아들일 수 있어야하기 때문에 순차적으로 처리해야만 하는 부분이라 볼 수 있음
- 모든 병렬 프로그램에는 항상 순차적으로 실행돼야만 하는 부분이 존재함
- 만약 그런 부분이 없다고 생각한다면, 프로그램 코드를 다시 한번 들여다보라

### 11.2.1 예제: 프레임웍 내부에 감춰져 있는 순차적 실행 구조
- 

